# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['unpack_smpl', 'unpack_smplh', 'unpack_smplh_from_mano', 'canonical_smpl_names', 'create_bmlink',
           'console_unpack', 'init_body_model', 'sample_betas', 'plottable', 'SMPLH_JOINT_NAMES']

# Cell
import shutil
from pathlib import Path
import numpy as np
import os
import pickle
import torch

# Cell

def unpack_smpl(smpl_dir):
    """`smplx.create` expects pkl files to be in SMPL directory,
    but this is not the structure of unzipped SMPL archives.
    This function fixes that."""
    for pkl_file in smpl_dir.glob('smpl/models/*.pkl'):
        target = smpl_dir/'smpl'/pkl_file.name
        if not target.exists():
            print(pkl_file, '-> ', target)
            os.rename(pkl_file, target)

# Cell

def unpack_smplh(smplh_dir):
    """`smplx.create` expects pkl files to be in `smplh` directory"""
    # unpack `smplh.tar.xz`
    target = smplh_dir/'smplh'
    archive_file = smplh_dir/'smplh.tar.xz'
    if not target.exists():
        target.mkdir(exist_ok=True)
        shutil.unpack_archive(archive_file, extract_dir=target)
    for gender in ['male', 'female', 'neutral']:
        subdir = target / gender
        for model_loc in subdir.glob('*.npz'):
            smplx_expects = target / f'SMPLH_{gender.upper()}.npz'
            os.rename(model_loc, smplx_expects)
            print(f'{model_loc} -> {smplx_expects}')
    return [p for p in target.glob('*.npz')]

# Cell

def unpack_smplh_from_mano(smplh_dir, use_smplh_archive=True):
    # unpack mano_v1_2.zip
    for archive_file in smplh_dir.glob('mano*.zip'):
        target = smplh_dir/archive_file.name.split('.')[0]
        if not target.exists():
            shutil.unpack_archive(archive_file, extract_dir=smplh_dir)
        model_dir = target / 'models'
        smplh_locs, output_fns = [], {}
        for mano_file in model_dir.glob('*.pkl'):
            if 'LEFT' in mano_file.name:
                mano_left_fn = mano_file
            elif 'RIGHT' in mano_file.name:
                mano_right_fn = mano_file
            elif 'SMPLH' in mano_file.name:
                smplh_locs.append(mano_file)
                output = mano_file.name.split('.')[0] + '.npz'
                output_fns[mano_file.name] = smplh_dir/'smplh'/output

    if use_smplh_archive:
        smplh_locs = unpack_smplh(smplh_dir)
        for p in smplh_locs:
            output_fns[p.name] = p

    # merge MANO and SMPLH file
    for smplh_fn in smplh_locs:
        def pkl_load(pkl_file):
            try:
                with open(pkl_file, 'rb') as f:
                    return pickle.load(f)
            except UnicodeDecodeError:
                with open(pkl_file, 'rb') as f:
                    u = pickle._Unpickler(f)
                    u.encoding = 'latin1'
                    return u.load()
        if smplh_fn.name.split('.')[1] == 'npz':
            body_data = np.load(smplh_fn)
            output_data = {k:body_data[k] for k in body_data}
        elif smplh_fn.name.split('.')[1] == 'pkl':
            body_data = pkl_load(smplh_fn)
            output_data = body_data.copy()
        lhand_data = pkl_load(mano_left_fn)
        rhand_data = pkl_load(mano_right_fn)

        output_data['hands_componentsl'] = lhand_data['hands_components']
        output_data['hands_componentsr'] = rhand_data['hands_components']

        output_data['hands_coeffsl'] = lhand_data['hands_coeffs']
        output_data['hands_coeffsr'] = rhand_data['hands_coeffs']

        output_data['hands_meanl'] = lhand_data['hands_mean']
        output_data['hands_meanr'] = rhand_data['hands_mean']

        for key, data in output_data.items():
            if 'chumpy' in str(type(data)):
                output_data[key] = np.array(data)
            else:
                output_data[key] = data

        class Struct(object):
            def __init__(self, **kwargs):
                for key, val in kwargs.items():
                    setattr(self, key, val)
        _struct = Struct(**output_data)
        assert hasattr(_struct, 'shapedirs')

        print(f'Saving to data with keys {[k for k in output_data.keys()]} to {smplh_fn}')
        np.savez(output_fns[smplh_fn.name], **output_data)

# Cell

def canonical_smpl_names(smpl_dir):
    "Canonical naming convention for SMPL body model files"
    for pkl_file in smpl_dir.glob('smpl/*.pkl'):
        gender = {'f':'FEMALE', 'm':'MALE', 'neutral':'NEUTRAL'}[pkl_file.name.split('_')[1]]
        target = smpl_dir/'smpl'/f'SMPL_{gender}.pkl'
        if not target.exists():
            print(pkl_file, '->', target)
            os.rename(pkl_file, target)

# Cell

def create_bmlink(bmloc):
    dotconfig = Path.home()/'.config/gaitplotlib'
    dotconfig.mkdir(parents=True, exist_ok=True)
    dst = dotconfig/bmloc.name
    if dst.is_symlink(): # always overwrite
        dst.unlink()
    print(f'Creating symlink to {bmloc} at {dst}')
    os.symlink(bmloc.absolute(), dst)

# Cell

import argparse

def console_unpack():
    parser = argparse.ArgumentParser(description='Unpack SMPL and SMPL-H body model archives.')
    parser.add_argument('bmdir', type=str,
                        help='Body model directory.')
    parser.add_argument('type', type=str,
                        choices=['smpl', 'smplh'],
                        help='Choose between SMPL and SMPL-H')
    args = parser.parse_args()
    bmdir = Path(args.bmdir)
    if args.smpl:
        unpack_smpl(bmdir)
        canonical_smpl_names(bmdir)
        for bmloc in bmdir.glob('smpl/*.npz'):
            create_bmlink(bmloc)
    elif args.smplh:
        unpack_smplh(bmdir)
        manoloc = next(bmdir.glob('mano*.zip'))
        if Path(manoloc).exists():
            unpack_smplh_from_mano(bmdir)
        for bmloc in bmdir.glob('smplh/*.npz'):
            create_bmlink(bmloc)

# Cell
from human_body_prior.body_model.body_model import BodyModel

def init_body_model(subject_gender, num_betas=16, num_dmpls=8):
    bm_fname = Path.home()/f'.config/gaitplotlib/SMPLH_{subject_gender.upper()}.npz'
    assert bm_fname.is_symlink()
    return BodyModel(
        bm_fname=str(bm_fname), num_betas=num_betas
        )

# Cell
def sample_betas(num_betas=16, seed=None):
    rng = np.random.RandomState(seed)
    return rng.randn(1, num_betas).astype(np.float32)

def plottable(pose_angles, betas=None, gender='neutral'):
    """Turn a vector or a batch of pose_angles from
    a set of angles into plottable coordinates in 3D space."""
    # if betas are not passed, sample a random body shape
    if betas is None:
        # seed so the same poses will get the same body shape
        seed = np.sum(np.abs(pose_angles*100).astype(int))
        betas = sample_betas(seed=seed)

    time_length = len(pose_angles)
    # map to tensors for body model module
    body_parms = {
        'betas': betas.reshape(1,-1).repeat(time_length, 0),
        'root_orient': pose_angles[:, :3],
        'pose_body':   pose_angles[:, 3:66],
        'pose_hand':   pose_angles[:, 66:]
    }
    body_parms = {k: torch.tensor(body_parms[k]).float() for k in body_parms}

    # initialise body model
    bm = init_body_model(gender)
    # forward pass for body_pose
    with torch.no_grad():
        body_pose = bm(**body_parms)

    # struct that can be indexed
    class IndexStruct():
        def __init__(self, **kwargs):
            self.keys = []
            for k,v in kwargs.items():
                self.keys.append(k)
                setattr(self, k, v)
        def __getitem__(self, i):
            # only index variables with a batch dimension
            v = {k:getattr(self, k)[i] for k in ['vertices', 'joints']}
            # dictionary union
            return dict(v, **{k:getattr(self, k) for k in set(self.keys)-set(v)})
        def __repr__(self):
            return "\n".join([f'{k}: {getattr(self, k).shape}' for k in self.keys])
    return IndexStruct(
        vertices=body_pose.v,
        joints=body_pose.Jtr,
        faces=body_pose.f,
        skeleton=bm.kintree_table.T[1:]
    )

# Cell
import smplx.joint_names

SMPLH_JOINT_NAMES = smplx.joint_names.SMPLH_JOINT_NAMES